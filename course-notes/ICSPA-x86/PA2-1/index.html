
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../PA1/">
      
      
        <link rel="next" href="../i386/">
      
      
      <link rel="icon" href="../../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.20">
    
    
      
        <title>PA2-1 - CSNote</title>
      
    
    
      <link rel="stylesheet" href="../../../assets/stylesheets/main.e53b48f4.min.css">
      
        
        <link rel="stylesheet" href="../../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Roboto";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../../stylesheets/extra.css">
    
      <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css">
    
      <link rel="stylesheet" href="https://fonts.loli.net/css?family=JetBrains Mono:400,500,600,700&display=swap">
    
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lxgw-wenkai-webfont@1.1.0/style.css">
    
    <script>__md_scope=new URL("../../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="black" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#pa2-1-note" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../../.." title="CSNote" class="md-header__button md-logo" aria-label="CSNote" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            CSNote
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              PA2-1
            
          </span>
        </div>
      </div>
    </div>
    
      
    
    
    
    
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../../.." title="CSNote" class="md-nav__button md-logo" aria-label="CSNote" data-md-component="logo">
      
  
  <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a3 3 0 0 0 3-3 3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3m0 3.54C9.64 9.35 6.5 8 3 8v11c3.5 0 6.64 1.35 9 3.54 2.36-2.19 5.5-3.54 9-3.54V8c-3.5 0-6.64 1.35-9 3.54"/></svg>

    </a>
    CSNote
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    index
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" >
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    OI-learning
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            OI-learning
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../OI-Learning/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    intro
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../OI-Learning/C%2B%2B%20OOP/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    C++ 面向对象
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_3" >
        
          
          <label class="md-nav__link" for="__nav_2_3" id="__nav_2_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Algorithm
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_3">
            <span class="md-nav__icon md-icon"></span>
            Algorithm
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../OI-Learning/Algorithm/STL_algorithm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    STL 算法库 ref
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../OI-Learning/Algorithm/fastpow/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    快速幂
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2_4" >
        
          
          <label class="md-nav__link" for="__nav_2_4" id="__nav_2_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Data Structure
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_2_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_2_4">
            <span class="md-nav__icon md-icon"></span>
            Data Structure
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../OI-Learning/Data-Structure/linkedlist/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    链表
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../OI-Learning/Data-Structure/vector/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    STL vector ref
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../OI-Learning/Data-Structure/stack/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    栈 && 单调栈
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../OI-Learning/Data-Structure/queue/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    队列 && 单调队列
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../OI-Learning/Data-Structure/hashmap/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    哈希表
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" checked>
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Course Notes
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Course Notes
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_1" checked>
        
          
          <label class="md-nav__link" for="__nav_3_1" id="__nav_3_1_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    ICSPA x86 note
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_1_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_3_1">
            <span class="md-nav__icon md-icon"></span>
            ICSPA x86 note
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../PA0/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PA0
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../PA1/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PA1
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    PA2-1
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    PA2-1
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#nemu" class="md-nav__link">
    <span class="md-ellipsis">
      NEMU 如何执行指令？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      模拟指令的实现
    </span>
  </a>
  
    <nav class="md-nav" aria-label="模拟指令的实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      操作数和操作数寻址
    </span>
  </a>
  
    <nav class="md-nav" aria-label="操作数和操作数寻址">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      操作数的封装
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modrm" class="md-nav__link">
    <span class="md-ellipsis">
      ModR/M
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sib" class="md-nav__link">
    <span class="md-ellipsis">
      SIB
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      进一步的封装
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    <span class="md-ellipsis">
      ---分隔线---
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tips-when-completing-pa" class="md-nav__link">
    <span class="md-ellipsis">
      Tips when completing PA
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../i386/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    i386 指令结构 for PA2-1
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../PA2-2/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    PA2-2
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    网络攻防实战 note
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            网络攻防实战 note
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Network-attack-and-defense-in-action/lab01/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab01
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Network-attack-and-defense-in-action/lab02/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab02
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Network-attack-and-defense-in-action/lab03/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab03
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Network-attack-and-defense-in-action/lab04/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab04
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../Network-attack-and-defense-in-action/lab05/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Lab05
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    ICS && CSAPP Labs
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            ICS && CSAPP Labs
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ICS%26%26CSAPP-Lab/intro/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    intro
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ICS%26%26CSAPP-Lab/Datalab/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    CSAPP Datalab
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ICS%26%26CSAPP-Lab/Bomblab/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    CSAPP Bomblab
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../ICS%26%26CSAPP-Lab/Binalab/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    ICS Binalab
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_4" >
        
          
          <label class="md-nav__link" for="__nav_4" id="__nav_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Deep Learning
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_4">
            <span class="md-nav__icon md-icon"></span>
            Deep Learning
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../../Deep-Learning/intro/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    intro
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#nemu" class="md-nav__link">
    <span class="md-ellipsis">
      NEMU 如何执行指令？
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#_1" class="md-nav__link">
    <span class="md-ellipsis">
      模拟指令的实现
    </span>
  </a>
  
    <nav class="md-nav" aria-label="模拟指令的实现">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_2" class="md-nav__link">
    <span class="md-ellipsis">
      操作数和操作数寻址
    </span>
  </a>
  
    <nav class="md-nav" aria-label="操作数和操作数寻址">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#_3" class="md-nav__link">
    <span class="md-ellipsis">
      操作数的封装
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#modrm" class="md-nav__link">
    <span class="md-ellipsis">
      ModR/M
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sib" class="md-nav__link">
    <span class="md-ellipsis">
      SIB
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#_4" class="md-nav__link">
    <span class="md-ellipsis">
      进一步的封装
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#-" class="md-nav__link">
    <span class="md-ellipsis">
      ---分隔线---
    </span>
  </a>
  
</li>
      
        <li class="md-nav__item">
  <a href="#tips-when-completing-pa" class="md-nav__link">
    <span class="md-ellipsis">
      Tips when completing PA
    </span>
  </a>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  



<h1 id="pa2-1-note">PA2-1 note</h1>
<div class="admonition quote">
<p class="admonition-title">可以先去看 i386 的指令结构 (for PA2) 了解一条指令的解析过程</p>
</div>
<div class="admonition caution">
<p class="admonition-title">由于 i386 手册上存在一些严重影响PA进行的笔误，所以请时刻注意<strong>手册是否存在笔误</strong>（尤其是出现难以理解的错误时）</p>
<p>这里有一个修正后的 i386 手册 https://github.com/NJU-ProjectN/i386-manual </p>
<p>上面的手册也会存在未修正的部分，你应该进行三方面验证：</p>
<p>**手册 - PA 框架代码 - <a href="http://www.felixcloutier.com/x86/" target="_blank">这个链接</a></p>
</div>
<div class="admonition warning">
<p class="admonition-title">本 note 基本不会给出代码实现，更接近于对实验手册的解读</p>
</div>
<h2 id="nemu">NEMU 如何执行指令？</h2>
<blockquote>
<p>指令循环的实现对应<code>nemu/src/cpu/cpu.c</code>中<code>void exec(uint32_t)</code>函数中的<code>while</code>循环。其中，<code>exec()</code>函数的参数为需要执行的指令条数，当满足条件时，CPU将不断地执行指令。</p>
<p>在<code>exec()</code>函数的<code>while</code>循环中，语句<code>len = exec_inst()</code>调用了函数<code>exec_inst()</code>。通过阅读代码注释，可以了解到<code>exec_inst()</code>函数的功能是执行EIP指向的指令，并返回指令的长度。</p>
</blockquote>
<p>这里贴出 <code>exec</code> 函数的代码，了解 NEMU 如何完成对一系列指令的执行：</p>
<div class="admonition quote">
<p class="admonition-title">英文注释是原程序自带的，不作改动</p>
</div>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">void</span><span class="w"> </span><span class="nf">exec</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w">   </span><span class="c1">// uint32_t n 作为指令条数传入函数</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// 初始化部分</span>
<span class="w">    </span><span class="k">static</span><span class="w"> </span><span class="n">BP</span><span class="w"> </span><span class="o">*</span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">;</span><span class="w">           </span><span class="c1">// BP 即 BreakPoint，它是一个指向当前断点的指针</span>
<span class="w">    </span><span class="n">verbose</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="mi">100000</span><span class="p">);</span><span class="w">        </span><span class="c1">// 一个 bool 变量，作用参考后面的补充内容</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">instr_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">              </span><span class="c1">// 存储每条指令的长度</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">hit_break_rerun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span><span class="w">   </span><span class="c1">// 标记当前是否为“从断点状态恢复执行”</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nemu_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NEMU_BREAK</span><span class="p">)</span><span class="w">   </span><span class="c1">// 判断当前是否为“从断点状态恢复执行”</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">hit_break_rerun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>

<span class="w">    </span><span class="n">nemu_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NEMU_RUN</span><span class="p">;</span><span class="w">          </span><span class="c1">// NEMU 的状态被设定为 RUN（正在运行）</span>
<span class="w">    </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">nemu_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NEMU_RUN</span><span class="p">)</span><span class="w">     </span><span class="c1">// 逐条执行程序的主循环</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">is_nemu_hlt</span><span class="p">)</span><span class="w">                        </span><span class="c1">// HALT 是“停止运行” 的指令</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">instr_len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">exec_inst</span><span class="p">();</span><span class="w">            </span><span class="c1">// 执行一条指令，函数的返回值是指令长度</span>
<span class="w">            </span><span class="n">cpu</span><span class="p">.</span><span class="n">eip</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">instr_len</span><span class="p">;</span><span class="w">               </span><span class="c1">// eip 在这里就是 PC 的具体实现</span>
<span class="w">            </span><span class="n">n</span><span class="o">--</span><span class="p">;</span><span class="w">                                </span><span class="c1">// 待运行指令数 -1</span>

<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">hit_break_rerun</span><span class="p">)</span><span class="w">                </span><span class="c1">// 如果是“从断点状态恢复执行”，进行恢复操作</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="n">resume_breakpoints</span><span class="p">();</span>
<span class="w">                </span><span class="n">hit_break_rerun</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">            </span><span class="c1">// 这部分内容是 “断点检测”</span>
<span class="w">            </span><span class="c1">// check for breakpoints</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nemu_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NEMU_BREAK</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// find break in the list</span>
<span class="w">                </span><span class="n">bp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">find_breakpoint</span><span class="p">(</span><span class="n">cpu</span><span class="p">.</span><span class="n">eip</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">                </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">bp</span><span class="p">)</span>
<span class="w">                </span><span class="p">{</span>
<span class="w">                    </span><span class="c1">// found, then restore the original opcode</span>
<span class="w">                    </span><span class="n">vaddr_write</span><span class="p">(</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">,</span><span class="w"> </span><span class="n">SREG_CS</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">ori_byte</span><span class="p">);</span>
<span class="w">                    </span><span class="n">cpu</span><span class="p">.</span><span class="n">eip</span><span class="o">--</span><span class="p">;</span>
<span class="w">                </span><span class="p">}</span>
<span class="w">                </span><span class="c1">// not found, it is triggered by BREAK_POINT in the code, do nothing</span>
<span class="w">            </span><span class="p">}</span>

<span class="w">            </span><span class="c1">// 这部分内容是“标记点检测”</span>
<span class="w">            </span><span class="c1">// check for watchpoints</span>

<span class="w">            </span><span class="n">BP</span><span class="w"> </span><span class="o">*</span><span class="n">wp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">scan_watchpoint</span><span class="p">();</span>
<span class="w">            </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">wp</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="nb">NULL</span><span class="p">)</span>
<span class="w">            </span><span class="p">{</span>
<span class="w">                </span><span class="c1">// print_bin_instr(eip_temp, instr_len);</span>
<span class="w">                </span><span class="c1">// puts(assembly);</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n\n</span><span class="s">Hit watchpoint %d at address 0x%08x, expr = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wp</span><span class="o">-&gt;</span><span class="n">NO</span><span class="p">,</span><span class="w"> </span><span class="n">cpu</span><span class="p">.</span><span class="n">eip</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">instr_len</span><span class="p">,</span><span class="w"> </span><span class="n">wp</span><span class="o">-&gt;</span><span class="n">expr</span><span class="p">);</span>
<span class="w">                </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;old value = %#08x</span><span class="se">\n</span><span class="s">new value = %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">wp</span><span class="o">-&gt;</span><span class="n">old_val</span><span class="p">,</span><span class="w"> </span><span class="n">wp</span><span class="o">-&gt;</span><span class="n">new_val</span><span class="p">);</span>
<span class="w">                </span><span class="n">wp</span><span class="o">-&gt;</span><span class="n">old_val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">wp</span><span class="o">-&gt;</span><span class="n">new_val</span><span class="p">;</span>
<span class="w">                </span><span class="n">nemu_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NEMU_READY</span><span class="p">;</span>
<span class="w">                </span><span class="k">break</span><span class="p">;</span>
<span class="w">            </span><span class="p">}</span>
<span class="w">        </span><span class="p">}</span>

<span class="w">    </span><span class="c1">// 这里是外接设备的处理（在 PA 4-2: 外设与I/O 才会通过添加宏启用）</span>
<span class="cp">#if defined(HAS_DEVICE_TIMER) || defined(HAS_DEVICE_VGA) || defined(HAS_DEVICE_KEYBOARD) || defined(HAS_DEVICE_AUDIO)</span>
<span class="w">    </span><span class="n">do_devices</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="c1">// 这里是中断处理（在 PA 4-1: 异常和中断的响应 才会通过添加宏启用）</span>
<span class="cp">#ifdef IA32_INTR</span>
<span class="w">        </span><span class="c1">// check for interrupt</span>
<span class="w">        </span><span class="n">do_intr</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">nemu_state</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">NEMU_STOP</span><span class="p">)</span><span class="w">            </span><span class="c1">// 虚拟机停止运行</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;NEMU2 terminated</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">    </span><span class="c1">// 这里也是中断处理，PA 4-1 会有更详细的解释）</span>
<span class="cp">#ifdef IA32_INTR</span>
<span class="w">        </span><span class="n">i8259_destroy</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">else</span><span class="w"> </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">                        </span><span class="c1">// 虚拟机做好了运行的准备</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">nemu_state</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NEMU_READY</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<details class="question">
<summary>如果你想知道 <code>BP</code> 是什么自定义的结构</summary>
<p><code>BP</code> 是定义断点的数据类型，定义于 <code>nemu/include/monitor/breakpoint.h</code>，你现在只需要知道 <code>BP</code> 记录了断点的相关信息即可</p>
<p>（这里有一个 TODO,但是我没有找到 PA 中需要修改这部分代码的任务）</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="k">struct</span><span class="w"> </span><span class="nc">breakpoint</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">ori_byte</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">enable</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">bool</span><span class="w"> </span><span class="n">in_use</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">NO</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">22</span><span class="p">;</span>

<span class="w">    </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">vaddr_t</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span>
<span class="w">        </span><span class="k">struct</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">expr</span><span class="p">;</span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">old_val</span><span class="p">;</span>
<span class="w">            </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">new_val</span><span class="p">;</span>
<span class="w">        </span><span class="p">};</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">;</span>
<span class="w">    </span><span class="k">struct</span><span class="w"> </span><span class="nc">breakpoint</span><span class="w"> </span><span class="o">*</span><span class="n">next</span><span class="p">;</span>

<span class="w">    </span><span class="cm">/* TODO: Add more member if necessary */</span>

<span class="p">}</span><span class="w"> </span><span class="n">BP</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
</details>
<details class="question">
<summary><code>verbose</code> 是个什么参数？</summary>
<p>这个参数用于控制调试信息的输入情况，比如 <code>nemu/include/cpu/instr_helper.h</code> 中有:</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#define decode_operand_o2a                    \</span>
<span class="cp">    opr_src.type = OPR_MEM;                   \</span>
<span class="cp">    opr_src.sreg = SREG_DS;                   \</span>
<span class="cp">    if (verbose)                              \</span>
<span class="cp">        clear_operand_mem_addr(&amp;opr_src);     \</span>
<span class="cp">    opr_src.addr = instr_fetch(eip + 1, 4);   \</span>
<span class="cp">    if (verbose)                              \</span>
<span class="cp">        opr_src.mem_addr.disp = opr_src.addr; \</span>
<span class="cp">    opr_dest.type = OPR_REG;                  \</span>
<span class="cp">    opr_dest.addr = REG_AL;                   \</span>
<span class="cp">    len += 4;</span>

<span class="cp">#define decode_operand_a2o                      \</span>
<span class="cp">    opr_dest.type = OPR_MEM;                    \</span>
<span class="cp">    opr_dest.sreg = SREG_DS;                    \</span>
<span class="cp">    if (verbose)                                \</span>
<span class="cp">        clear_operand_mem_addr(&amp;opr_dest);      \</span>
<span class="cp">    opr_dest.addr = instr_fetch(eip + 1, 4);    \</span>
<span class="cp">    if (verbose)                                \</span>
<span class="cp">        opr_dest.mem_addr.disp = opr_dest.addr; \</span>
<span class="cp">    opr_src.type = OPR_REG;                     \</span>
<span class="cp">    opr_src.addr = REG_AL;                      \</span>
<span class="cp">    len += 4;</span>
</code></pre></div></td></tr></table></div>
<p>这里有两个宏函数，<code>verbose</code> 为 <code>true</code> 时可以输出更多关于内存操作/寄存器状态的细节，我们理解为 “调试模式”。在 <code>exec</code> 函数中，我们规定指令数 &lt;= 100000 时输出一些更详细的内容，否则为了输出的简洁性将 verbose 设置为 <code>false</code></p>
<p>以及很快还会见到这两个函数的</p>
</details>
<p>对于如何执行单条指令，有 <code>exec_inst</code> 函数：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// in nemu/src/cpu/cpu.c</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">exec_inst</span><span class="p">()</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="c1">// get the opcode</span>
<span class="w">    </span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instr_fetch</span><span class="p">(</span><span class="n">cpu</span><span class="p">.</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">   </span><span class="c1">// 通过程序计数器获取当前指令的第一个字节</span>


<span class="c1">// printf(&quot;opcode = %x, eip = %x\n&quot;, opcode, cpu.eip);  // 一个插桩操作 Instrumentation</span>
<span class="c1">// instruction decode and execution</span>
<span class="cp">#ifdef NEMU_REF_INSTR                   </span><span class="c1">// 这里有一个 “参考实现” 的切换</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__ref_opcode_entry</span><span class="p">[</span><span class="n">opcode</span><span class="p">](</span><span class="n">cpu</span><span class="p">.</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">opcode</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opcode_entry</span><span class="p">[</span><span class="n">opcode</span><span class="p">](</span><span class="n">cpu</span><span class="p">.</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">opcode</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">len</span><span class="p">;</span><span class="w"> </span><span class="c1">// 返回指令长度</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<details class="question">
<summary>这里附带了 <code>instr_fetch</code> 函数的实现</summary>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// in nemu/src/memory/memory.c</span>
<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">instr_fetch</span><span class="p">(</span><span class="n">vaddr_t</span><span class="w"> </span><span class="n">vaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">vaddr_read</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span><span class="w"> </span><span class="n">SREG_CS</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">vaddr_read</span><span class="p">(</span><span class="n">vaddr_t</span><span class="w"> </span><span class="n">vaddr</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">sreg</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">assert</span><span class="p">(</span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">laddr_read</span><span class="p">(</span><span class="n">vaddr</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">laddr_read</span><span class="p">(</span><span class="n">laddr_t</span><span class="w"> </span><span class="n">laddr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">paddr_read</span><span class="p">(</span><span class="n">laddr</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">paddr_read</span><span class="p">(</span><span class="n">paddr_t</span><span class="w"> </span><span class="n">paddr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">hw_mem_read</span><span class="p">(</span><span class="n">paddr</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint32_t</span><span class="w"> </span><span class="nf">hw_mem_read</span><span class="p">(</span><span class="n">paddr_t</span><span class="w"> </span><span class="n">paddr</span><span class="p">,</span><span class="w"> </span><span class="kt">size_t</span><span class="w"> </span><span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ret</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="p">,</span><span class="w"> </span><span class="n">hw_mem</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">paddr</span><span class="p">,</span><span class="w"> </span><span class="n">len</span><span class="p">);</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>为什么要嵌套多层函数最后只是为了执行 <code>hw_mem_read</code> 这一步？</p>
<p>这是为了模拟 x86-64 的内存管理机制，参见 “物理地址、虚拟地址、线性地址、逻辑地址” 这些内存概念</p>
</details>
<p><code>exec_inst</code> 函数先通过 <code>instr_fetch</code> 获取 opcode，然后通过下面的函数进行指令执行：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opcode_entry</span><span class="p">[</span><span class="n">opcode</span><span class="p">](</span><span class="n">cpu</span><span class="p">.</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">opcode</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>
<p>这里 <code>opcode_entry</code> 是一个函数指针数组，在 <code>nemu/src/cpu/decode/opcode.c</code> 中有</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// From nemu/include/cpu/instr_helper.h:</span>
<span class="c1">// typedef int (*instr_func)(uint32_t eip, uint8_t opcode);</span>

<span class="n">instr_func</span><span class="w"> </span><span class="n">opcode_entry</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="cm">/* 目前这里的 inv 都是占位符，需要具体实现 */</span>
<span class="w">    </span><span class="cm">/* 0x00 - 0x03*/</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span>
<span class="w">    </span><span class="cm">/* 0x04 - 0x07*/</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span>
<span class="w">    </span><span class="cm">/* 0x08 - 0x0b*/</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span>
<span class="w">    </span><span class="cm">/* 0x0c - 0x0f*/</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">opcode_2_byte</span><span class="p">,</span>
<span class="w">    </span><span class="cm">/* ... */</span>
<span class="w">    </span><span class="cm">/* 0xf0 - 0xf3*/</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">break_point</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">rep_repe</span><span class="p">,</span>
<span class="w">    </span><span class="cm">/* 0xf4 - 0xf7*/</span><span class="w"> </span><span class="n">hlt</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">group_3_b</span><span class="p">,</span><span class="w"> </span><span class="n">group_3_v</span><span class="p">,</span>
<span class="w">    </span><span class="cm">/* 0xf8 - 0xfb*/</span><span class="w"> </span><span class="n">clc</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span>
<span class="w">    </span><span class="cm">/* 0xfc - 0xff*/</span><span class="w"> </span><span class="n">cld</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">group_5_indirect</span><span class="p">,</span>
<span class="p">};</span>
</code></pre></div></td></tr></table></div>
<details class="example">
<summary>如何理解上面的内容？</summary>
<p>首先是下面的类型定义：</p>
<p><code>typedef int (*instr_func)(uint32_t eip, uint8_t opcode);</code></p>
<p>这里定义了一个 <code>instr_func</code> 类型，表示为函数指针，并且专门指向参数为 <code>(uint32_t eip, uint8_t opcode)</code>，返回值为 <code>int</code> 的函数，下面是一个使用例：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">instr_func</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">op_func</span><span class="p">;</span><span class="w">    </span><span class="c1">// op_func 是一个签名符合上述要求的函数</span>
<span class="kt">int</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="p">(</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">opcode</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>
<p>在定义了 <code>instr_func</code> 后，构建一个存储 <code>instr_func</code> 的数组（即 <code>opcode_entry</code>），在 <code>opcode_entry</code> 中放置对应函数，这样通过数组索引就可以在 O(1) 的时间复杂度下获取 opcode 对应的函数，比如：</p>
<p><div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">typedef</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="p">(</span><span class="o">*</span><span class="n">instr_func</span><span class="p">)(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">opcode</span><span class="p">);</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">ADD_rm8_reg8</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">opcode</span><span class="p">){</span>
<span class="w">    </span><span class="c1">// 具体的函数实现...</span>
<span class="p">}</span>
<span class="cm">/* 其他函数... */</span>

<span class="n">instr_func</span><span class="w"> </span><span class="n">opcode_entry</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">ADD_rm8_reg8</span><span class="p">,</span>
<span class="w">    </span><span class="cm">/* ... */</span>
<span class="p">}</span>

<span class="c1">// 下面的操作即完成了一次指令执行</span>
<span class="kt">uint8_t</span><span class="w"> </span><span class="n">opcode</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instr_fetch</span><span class="p">(</span><span class="n">cpu</span><span class="p">.</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="n">res</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opcode_entry</span><span class="p">[</span><span class="n">opcode</span><span class="p">](</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">opcode</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>
（具体的实现参考 NEMU 源代码）</p>
</details>
<details class="example">
<summary>如果一条指令包含 <code>0x66</code> 前缀，如何正确读取 opcode？</summary>
<p>在 NEMU 的实现中，<code>0x66</code> 在 <code>opcode_entry[0x66]</code> 中有单独的操作</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="w"> </span><span class="cm">/* 0x64 - 0x67*/</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span><span class="w"> </span><span class="n">data_size_16</span><span class="p">,</span><span class="w"> </span><span class="n">inv</span><span class="p">,</span>
</code></pre></div></td></tr></table></div>
<p>在 nemu/src/cpu/instr/data_size.c 中有</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;cpu/instr.h&quot;</span>

<span class="k">extern</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">data_size</span><span class="p">;</span><span class="w">   </span><span class="c1">// 这里有一个全局变量</span>
<span class="k">extern</span><span class="w"> </span><span class="kt">bool</span><span class="w"> </span><span class="n">has_prefix</span><span class="p">;</span><span class="w">     </span><span class="c1">// 同上</span>

<span class="c1">// make_instr_func(data_size_16) 是 data_size_16(uint32_t eip, uint8_t opcode) 的宏封装</span>
<span class="c1">// 之后会提到</span>
<span class="n">make_instr_func</span><span class="p">(</span><span class="n">data_size_16</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">op_code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="n">data_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">16</span><span class="p">;</span>
<span class="w">    </span><span class="n">has_prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">true</span><span class="p">;</span>
<span class="w">    </span><span class="n">op_code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instr_fetch</span><span class="p">(</span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="cp">#ifdef NEMU_REF_INSTR</span>
<span class="w">    </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">__ref_opcode_entry</span><span class="p">[</span><span class="n">op_code</span><span class="p">](</span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">op_code</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="w">    </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opcode_entry</span><span class="p">[</span><span class="n">op_code</span><span class="p">](</span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">op_code</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="w">    </span><span class="n">data_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">32</span><span class="p">;</span>
<span class="w">    </span><span class="n">has_prefix</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nb">false</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>简单来说，<code>0x66</code> 被当作一条完整的指令执行（而不是某一条指令的前缀），通过全局变量 <code>data_size</code> 和 <code>has_prefix</code> 传递前缀信息（对接下来的指令有效），这样就实现了 <code>0x66</code> 前缀的读取，同时不需要为每个操作额外加上 <code>0x66</code> 的判断</p>
</details>
<h2 id="_1">模拟指令的实现</h2>
<div class="admonition quote">
<p class="admonition-title">“一条简单mov指令的实现” 的部分可以认真看看</p>
<p>简单来说，我们需要做的就是：</p>
<ol>
<li>
<p>实现指令，以 <code>b1 01: movb $1, %cl</code> 为例：
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">mov_i2r_b</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">opcode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">imm</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instr_fetch</span><span class="p">(</span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w"> </span><span class="c1">// 获取立即数</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">regIdx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opcode</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x7</span><span class="p">;</span><span class="w">  </span><span class="c1">// 获取寄存器编号</span>
<span class="w">    </span><span class="n">cpu</span><span class="p">.</span><span class="n">gpr</span><span class="p">[</span><span class="n">regIdx</span><span class="p">].</span><span class="n">_8</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">imm</span><span class="p">;</span><span class="w"> </span><span class="c1">// 完成mov动作 </span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w"> </span><span class="c1">// 返回指令长度</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div></p>
</li>
<li>
<p>在 <code>mov.h</code> 中声明函数，在 <code>instr.h</code> 中引用头文件 <code>#include "cpu/instr/mov.h"</code></p>
</li>
<li>
<p>在 <code>opcode.c</code> 中修改 opcode_entry 中的相关内容，容易得到 <code>mov_i2r_b</code> 这个函数对 <code>0xB0 ~ 0xB7</code> 的 opcode 都适用，所以把这几个元素的 <code>inv</code> 都修改为 <code>mov_i2r_b</code> </p>
</li>
</ol>
<p>但是事实上 mov 指令有很多变种，不同的变种的大致框架是一样的，我们希望抽象出部分相同逻辑，封装提供调用，简化逻辑</p>
</div>
<p>NEMU 中对一些函数/结构进行了封装：</p>
<h3 id="_2">操作数和操作数寻址</h3>
<h4 id="_3">操作数的封装</h4>
<blockquote>
<p>NEMU中所有的操作数都封装在一个叫做<code>OPERAND</code>的数据结构中。该数据结构的声明在头文件<code>nemu/include/cpu/operand.h</code>中</p>
</blockquote>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// nemu/include/cpu/operand.h</span>
<span class="cp">#ifndef __OPERAND_H__</span>
<span class="cp">#define __OPERAND_H__</span>

<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;nemu.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;cpu/cpu.h&quot;</span>
<span class="cp">#include</span><span class="w"> </span><span class="cpf">&quot;memory/memory.h&quot;</span>

<span class="c1">// operand type for immediate number, register, and memory</span>
<span class="k">enum</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">OPR_IMM</span><span class="p">,</span><span class="w">   </span><span class="c1">// 立即数</span>
<span class="w">    </span><span class="n">OPR_REG</span><span class="p">,</span><span class="w">   </span><span class="c1">// 寄存器</span>
<span class="w">    </span><span class="n">OPR_MEM</span><span class="p">,</span><span class="w">   </span><span class="c1">// 内存</span>
<span class="w">    </span><span class="n">OPR_CREG</span><span class="p">,</span><span class="w">  </span><span class="c1">// 控制寄存器</span>
<span class="w">    </span><span class="n">OPR_SREG</span><span class="w">   </span><span class="c1">// 段寄存器</span>
<span class="p">};</span>

<span class="cp">#define MEM_ADDR_NA 0xffffffff</span>

<span class="c1">//enum {MEM_ADDR_OFF, MEM_ADDR_SIB};</span>

<span class="c1">// 内存地址结构体 (MEM_ADDR)</span>
<span class="c1">// 描述了内存的寻址方式</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span>
<span class="p">{</span>
<span class="w">    </span><span class="c1">// uint32_t type;</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">disp</span><span class="p">;</span><span class="w">  </span><span class="c1">// hex</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="p">;</span><span class="w">  </span><span class="c1">// register</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="p">;</span><span class="w"> </span><span class="c1">// register</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">scale</span><span class="p">;</span><span class="w"> </span><span class="c1">// 1, 2, 4, 8</span>
<span class="p">}</span><span class="w"> </span><span class="n">MEM_ADDR</span><span class="p">;</span><span class="w">         </span><span class="c1">// memory address details</span>

<span class="c1">// 操作数结构体 (OPERAND)</span>
<span class="c1">// 包含了一个操作数的完整信息</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">struct</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">type</span><span class="p">;</span><span class="w">           </span><span class="c1">// 操作数类型</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">addr</span><span class="p">;</span><span class="w">      </span><span class="c1">// 地址</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">sreg</span><span class="p">;</span><span class="w">       </span><span class="c1">// 段寄存器</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">val</span><span class="p">;</span><span class="w">       </span><span class="c1">// 数据内容</span>
<span class="w">    </span><span class="kt">size_t</span><span class="w"> </span><span class="n">data_size</span><span class="p">;</span><span class="w">   </span><span class="c1">// 数据大小</span>
<span class="w">    </span><span class="n">MEM_ADDR</span><span class="w"> </span><span class="n">mem_addr</span><span class="p">;</span><span class="w">  </span><span class="c1">// 内存地址的详细信息（包括寻址方式）</span>
<span class="p">}</span><span class="w"> </span><span class="n">OPERAND</span><span class="p">;</span>

<span class="k">extern</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="n">opr_src</span><span class="p">,</span><span class="w"> </span><span class="n">opr_dest</span><span class="p">;</span>

<span class="c1">// 以下是对读写 OPERAND 的相关封装</span>

<span class="c1">// read the operand&#39;s value from its addr</span>
<span class="c1">// 从操作数地址读取值</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">operand_read</span><span class="p">(</span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">opr</span><span class="p">);</span>

<span class="c1">// write the operand&#39;s value to its addr</span>
<span class="c1">// 将值写入操作数地址</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">operand_write</span><span class="p">(</span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">opr</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">operand_write_cr0</span><span class="p">(</span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">opr</span><span class="p">);</span>

<span class="kt">void</span><span class="w"> </span><span class="nf">parse_operand_address</span><span class="p">(</span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">opr</span><span class="p">,</span><span class="w"> </span><span class="kt">char</span><span class="w"> </span><span class="o">*</span><span class="n">str</span><span class="p">);</span>
<span class="kt">void</span><span class="w"> </span><span class="nf">clear_operand_mem_addr</span><span class="p">(</span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">opr</span><span class="p">);</span>

<span class="cp">#endif</span>
</code></pre></div></td></tr></table></div>
<p>这样的封装设计能够应对复杂的操作数寻址模式的处理，比如我们现在重写 <code>mov_i2r_b</code> 函数：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">mov_i2r_b</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">opcode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">OPERAND</span><span class="w"> </span><span class="n">imm</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">;</span><span class="w">        </span><span class="c1">// 创建源操作数和目的操作数局部变量</span>

<span class="w">    </span><span class="n">imm</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OPR_IMM</span><span class="p">;</span><span class="w">    </span><span class="c1">// 配置源操作数类型</span>
<span class="w">    </span><span class="n">imm</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SREG_CS</span><span class="p">;</span><span class="w">    </span><span class="c1">// 设置段寄存器，PA 3-2 开始涉及</span>
<span class="w">    </span><span class="n">imm</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w">    </span><span class="c1">// 配置源操作数地址</span>
<span class="w">    </span><span class="n">imm</span><span class="p">.</span><span class="n">data_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">     </span><span class="c1">// 配置源操作数长度</span>

<span class="w">    </span><span class="n">r</span><span class="p">.</span><span class="n">data_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">        </span><span class="c1">// 配置目的操作数类型</span>
<span class="w">    </span><span class="n">r</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OPR_REG</span><span class="p">;</span><span class="w">       </span><span class="c1">// 配置目的操作数类型</span>
<span class="w">    </span><span class="n">r</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opcode</span><span class="w"> </span><span class="o">&amp;</span><span class="w"> </span><span class="mh">0x7</span><span class="p">;</span><span class="w">  </span><span class="c1">// 配置目的操作数类型</span>

<span class="w">    </span><span class="n">operand_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imm</span><span class="p">);</span><span class="w">   </span><span class="c1">// 读源操作数的值</span>
<span class="w">    </span><span class="n">r</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">imm</span><span class="p">.</span><span class="n">val</span><span class="p">;</span><span class="w">      </span><span class="c1">// 将源操作数的值赋给目的操作数</span>
<span class="w">    </span><span class="n">operand_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">r</span><span class="p">);</span><span class="w">    </span><span class="c1">// 写入目的操作数，完成mov动作</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span><span class="w">             </span><span class="c1">// 返回指令长度</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>虽然代码量更大了，但是函数的设计更加规整，可以用较为固定化的方式高效实现一系列的 mov 函数</p>
<hr />
<p>现在我们进一步实现 “操作数寻址” 的细节，这其中的核心是对 ModR/M 字段与 SIB 字段的解析</p>
<h4 id="modrm">ModR/M</h4>
<p>回顾 ：ModR/M 字段总共分为三部分：Mod + Opcode/Reg + R/M</p>
<blockquote>
<p>在头文件<code>nemu/include/cpu/modrm.h</code>中，声明了<code>ModR/M</code>字节的结构定义和四个函数：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">modrm_rm</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rm</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">modrm_r_rm</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rm</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">modrm_opcode_rm</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">opcode</span><span class="p">,</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">rm</span><span class="p">);</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">modrm_opcode</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">opcode</span><span class="p">);</span>
</code></pre></div></td></tr></table></div>
<p>这四个函数分别对应指令希望通过解析<code>ModR/M</code>字节所获得的数据的四种不同类型组合，已涵盖实验中所涉及的所有指令。</p>
</blockquote>
<p>我们以 <code>modrm_r_rm</code> 函数为例具体分析，为了展示调用关系，将内层函数放在了更后面：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// From modrm.h</span>
<span class="c1">// 很显然的定义</span>
<span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">rm</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">reg_opcode</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mod</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">MODRM</span><span class="p">;</span>

<span class="c1">// From modrm.c</span>
<span class="c1">// modrm 有四种类型组合，这里只展示 r_rm 型</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">modrm_r_rm</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">rm</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">MODRM</span><span class="w"> </span><span class="n">modrm</span><span class="p">;</span><span class="w">                                </span><span class="c1">// 定义一个 ModR/M</span>
<span class="w">    </span><span class="n">modrm</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instr_fetch</span><span class="p">(</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">            </span><span class="c1">// 通过 instr_fetch 填充</span>
<span class="w">    </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OPR_REG</span><span class="p">;</span><span class="w">                          </span><span class="c1">// 第一个操作数 r 类型设置为“寄存器”</span>
<span class="w">    </span><span class="n">r</span><span class="o">-&gt;</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">modrm</span><span class="p">.</span><span class="n">reg_opcode</span><span class="p">;</span><span class="w">                 </span><span class="c1">// 其地址设置为 Reg/Opcode 字段</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">parse_rm_32</span><span class="p">(</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">modrm</span><span class="p">,</span><span class="w"> </span><span class="n">rm</span><span class="p">);</span><span class="w">      </span><span class="c1">// 第二个操作数 rm 调用函数处理</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">parse_rm_32</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">MODRM</span><span class="w"> </span><span class="n">modrm</span><span class="p">,</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">opr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// modr/m 的长度</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">verbose</span><span class="p">)</span>
<span class="w">        </span><span class="n">clear_operand_mem_addr</span><span class="p">(</span><span class="n">opr</span><span class="p">);</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">modrm</span><span class="p">.</span><span class="n">mod</span><span class="p">)</span><span class="w">                          </span><span class="c1">// 根据 mod 设置 rm </span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">case_mod_00</span><span class="p">(</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">modrm</span><span class="p">,</span><span class="w"> </span><span class="n">opr</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">case_mod_01</span><span class="p">(</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">modrm</span><span class="p">,</span><span class="w"> </span><span class="n">opr</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">case_mod_10</span><span class="p">(</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">modrm</span><span class="p">,</span><span class="w"> </span><span class="n">opr</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">3</span><span class="p">:</span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">case_mod_11</span><span class="p">(</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">modrm</span><span class="p">,</span><span class="w"> </span><span class="n">opr</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 四个 case_mod 函数都很直白，此处只展示其中两个</span>
<span class="c1">// Mod = 01，对应带 disp8 偏移量的内存寻址</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">case_mod_01</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">MODRM</span><span class="w"> </span><span class="n">modrm</span><span class="p">,</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">opr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="kt">int8_t</span><span class="w"> </span><span class="n">disp8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">modrm</span><span class="p">.</span><span class="n">rm</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>

<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">4</span><span class="p">:</span><span class="w"> </span><span class="c1">//disp8 SIB</span>
<span class="w">        </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OPR_MEM</span><span class="p">;</span>
<span class="w">        </span><span class="c1">//len += parse_sib(eip + 1, modrm.mod, &amp;opr-&gt;addr, &amp;opr-&gt;sreg);</span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">parse_sib</span><span class="p">(</span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="n">modrm</span><span class="p">.</span><span class="n">mod</span><span class="p">,</span><span class="w"> </span><span class="n">opr</span><span class="p">);</span><span class="w">      </span><span class="c1">// 这里是 SIB 字节的处理</span>
<span class="w">        </span><span class="n">disp8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="n">instr_fetch</span><span class="p">(</span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// disp8</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>

<span class="w">    </span><span class="k">default</span><span class="o">:</span><span class="w"> </span><span class="c1">//disp8[EXX]</span>
<span class="w">        </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OPR_MEM</span><span class="p">;</span>
<span class="w">        </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu</span><span class="p">.</span><span class="n">gpr</span><span class="p">[</span><span class="n">modrm</span><span class="p">.</span><span class="n">rm</span><span class="p">].</span><span class="n">_32</span><span class="p">;</span>
<span class="w">        </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">mem_addr</span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">modrm</span><span class="p">.</span><span class="n">rm</span><span class="p">;</span><span class="w">                  </span><span class="c1">// 参考 OPERAND 的结构体实现</span>
<span class="w">        </span><span class="n">disp8</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="kt">int8_t</span><span class="p">)</span><span class="n">instr_fetch</span><span class="p">(</span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span>
<span class="w">        </span><span class="n">len</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span><span class="w"> </span><span class="c1">// disp8</span>
<span class="w">        </span><span class="c1">// 这里是段寄存器的操作</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">modrm</span><span class="p">.</span><span class="n">rm</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="w">        </span><span class="p">{</span><span class="w"> </span><span class="c1">// EBP</span>
<span class="w">            </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">sreg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SREG_SS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">else</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">sreg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SREG_DS</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">disp8</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">(</span><span class="kt">int32_t</span><span class="p">)</span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="p">;</span><span class="w">             </span><span class="c1">// 地址计算</span>
<span class="w">    </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">mem_addr</span><span class="p">.</span><span class="n">disp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">disp8</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Mod = 11，对应直接寄存器</span>
<span class="kt">int</span><span class="w"> </span><span class="nf">case_mod_11</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="n">MODRM</span><span class="w"> </span><span class="n">modrm</span><span class="p">,</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">opr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OPR_REG</span><span class="p">;</span>
<span class="w">    </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">modrm</span><span class="p">.</span><span class="n">rm</span><span class="p">;</span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h4 id="sib">SIB</h4>
<p>对 SIB 字节的结构定义<code>nemu/include/cpu/sib.h</code> 与函数 <code>nemu/src/cpu/decode/sib.c</code> </p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// 内存寻址方式 [Base + Index * Scale + Disp]</span>

<span class="k">typedef</span><span class="w"> </span><span class="k">union</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="k">struct</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">base</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">index</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">3</span><span class="p">;</span>
<span class="w">        </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">ss</span><span class="w"> </span><span class="o">:</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">    </span><span class="p">};</span>
<span class="w">    </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">val</span><span class="p">;</span>
<span class="p">}</span><span class="w"> </span><span class="n">SIB</span><span class="p">;</span>

<span class="kt">int</span><span class="w"> </span><span class="nf">parse_sib</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">mod</span><span class="p">,</span><span class="w"> </span><span class="n">OPERAND</span><span class="w"> </span><span class="o">*</span><span class="n">opr</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">    </span><span class="n">SIB</span><span class="w"> </span><span class="n">sib</span><span class="p">;</span><span class="w">                                    </span><span class="c1">// 定义一个 SIB</span>
<span class="w">    </span><span class="n">sib</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instr_fetch</span><span class="p">(</span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">);</span><span class="w">              </span><span class="c1">// 取值填充</span>
<span class="w">    </span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span><span class="w">                           </span><span class="c1">// 变址值初始化</span>
<span class="w">    </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">sreg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SREG_DS</span><span class="p">;</span><span class="w">                        </span><span class="c1">// 段寄存器选择</span>

<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sib</span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="n">sib</span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">         </span><span class="c1">// 段寄存器选择</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">sreg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SREG_SS</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="cm">/* 特例：当 Index = 100 时，看作“Index = NULL”（不使用变址寄存器），而不是 “Index = ESP” */</span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sib</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="mi">4</span><span class="p">)</span><span class="w">                         </span><span class="c1">// 启用了变址寄存器</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">        </span><span class="n">idx</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu</span><span class="p">.</span><span class="n">gpr</span><span class="p">[</span><span class="n">sib</span><span class="p">.</span><span class="n">index</span><span class="p">].</span><span class="n">_32</span><span class="p">;</span><span class="w">           </span><span class="c1">// 获取变址寄存器的 32 位值</span>
<span class="w">        </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">mem_addr</span><span class="p">.</span><span class="n">index</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sib</span><span class="p">.</span><span class="n">index</span><span class="p">;</span><span class="w">        </span><span class="c1">// 记录变址寄存器的 id</span>
<span class="w">        </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">sib</span><span class="p">.</span><span class="n">ss</span><span class="p">)</span><span class="w">                         </span><span class="c1">// 缩放因子</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mh">0x0</span><span class="p">:</span>
<span class="w">            </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">mem_addr</span><span class="p">.</span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mh">0x1</span><span class="p">:</span>
<span class="w">            </span><span class="n">idx</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">mem_addr</span><span class="p">.</span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">2</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mh">0x2</span><span class="p">:</span>
<span class="w">            </span><span class="n">idx</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">            </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">mem_addr</span><span class="p">.</span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">case</span><span class="w"> </span><span class="mh">0x3</span><span class="p">:</span>
<span class="w">            </span><span class="n">idx</span><span class="w"> </span><span class="o">*=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">            </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">mem_addr</span><span class="p">.</span><span class="n">scale</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span>
<span class="w">            </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="p">}</span>
<span class="w">    </span><span class="k">switch</span><span class="w"> </span><span class="p">(</span><span class="n">mod</span><span class="p">)</span><span class="w">                                </span>
<span class="w">    </span><span class="p">{</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">0</span><span class="p">:</span><span class="w"> </span><span class="c1">// only now has additional disp32?</span>
<span class="w">        </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">sib</span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">5</span><span class="p">)</span>
<span class="w">        </span><span class="cm">/* 特例：当 Base = 101 且 Mod = 00 时，看作“Base = NULL”（不使用基址寄存器），而不是 “Base = EBP”，同时启用 Disp32 */</span>
<span class="w">        </span><span class="p">{</span>
<span class="w">            </span><span class="kt">int32_t</span><span class="w"> </span><span class="n">disp32</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">instr_fetch</span><span class="p">(</span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">4</span><span class="p">);</span>
<span class="w">            </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">idx</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">disp32</span><span class="p">;</span>
<span class="w">            </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">mem_addr</span><span class="p">.</span><span class="n">disp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">disp32</span><span class="p">;</span>
<span class="w">            </span><span class="k">return</span><span class="w"> </span><span class="mi">5</span><span class="p">;</span>
<span class="w">        </span><span class="p">}</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">1</span><span class="p">:</span>
<span class="w">    </span><span class="k">case</span><span class="w"> </span><span class="mi">2</span><span class="p">:</span>
<span class="w">        </span><span class="c1">// 正常情况下</span>
<span class="w">        </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">cpu</span><span class="p">.</span><span class="n">gpr</span><span class="p">[</span><span class="n">sib</span><span class="p">.</span><span class="n">base</span><span class="p">].</span><span class="n">_32</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">idx</span><span class="p">;</span>
<span class="w">        </span><span class="n">opr</span><span class="o">-&gt;</span><span class="n">mem_addr</span><span class="p">.</span><span class="n">base</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">sib</span><span class="p">.</span><span class="n">base</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="k">default</span><span class="o">:</span>
<span class="w">        </span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;illegal mod=11 in SIB</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="w">        </span><span class="n">fflush</span><span class="p">(</span><span class="n">stdout</span><span class="p">);</span>
<span class="w">        </span><span class="n">assert</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
<span class="w">        </span><span class="k">break</span><span class="p">;</span>
<span class="w">        </span><span class="k">return</span><span class="w"> </span><span class="mi">0</span><span class="p">;</span>
<span class="w">    </span><span class="p">}</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<h3 id="_4">进一步的封装</h3>
<p>现在我们有一个 <code>mov_i2rm_v</code> 指令 （将一个立即数 <code>mov</code> 到一个由 <code>ModR/M</code> 字节所表达的寄存器或内存地址（R/M）中，位数不定）</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="kt">int</span><span class="w"> </span><span class="nf">mov_i2rm_v</span><span class="p">(</span><span class="kt">uint32_t</span><span class="w"> </span><span class="n">eip</span><span class="p">,</span><span class="w"> </span><span class="kt">uint8_t</span><span class="w"> </span><span class="n">opcode</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">OPERAND</span><span class="w"> </span><span class="n">rm</span><span class="p">,</span><span class="w"> </span><span class="n">imm</span><span class="p">;</span>

<span class="w">    </span><span class="n">imm</span><span class="p">.</span><span class="n">data_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">rm</span><span class="p">.</span><span class="n">data_size</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">data_size</span><span class="p">;</span><span class="w"> </span><span class="c1">// 解码操作数：指定操作数长度</span>
<span class="w">                                              </span><span class="c1">// data_size 会受到 0x66 的影响</span>
<span class="w">    </span><span class="kt">int</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">1</span><span class="p">;</span>
<span class="w">    </span><span class="n">len</span><span class="w"> </span><span class="o">+=</span><span class="w"> </span><span class="n">modrm_rm</span><span class="p">(</span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="o">&amp;</span><span class="n">rm</span><span class="p">);</span><span class="w">            </span><span class="c1">// 解码操作数：操作数寻址</span>
<span class="w">    </span><span class="n">imm</span><span class="p">.</span><span class="n">type</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">OPR_IMM</span><span class="p">;</span>
<span class="w">    </span><span class="n">imm</span><span class="p">.</span><span class="n">sreg</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">SREG_CS</span><span class="p">;</span>
<span class="w">    </span><span class="n">imm</span><span class="p">.</span><span class="n">addr</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">eip</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">len</span><span class="p">;</span>

<span class="w">    </span><span class="n">operand_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">imm</span><span class="p">);</span><span class="w">                       </span><span class="c1">// mov操作</span>
<span class="w">    </span><span class="n">rm</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">imm</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="n">operand_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rm</span><span class="p">);</span>

<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">len</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">data_size</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="mi">8</span><span class="p">;</span><span class="w">               </span><span class="c1">// 返回长度</span>
<span class="p">}</span>
</code></pre></div></td></tr></table></div>
<p>以这个两操作数的指令为例，进行进一步的封装、简化操作：</p>
<div class="admonition question">
<p class="admonition-title">前置知识：<code>concat</code> 宏</p>
<p>concat 系列宏可以将多个参数硬拼接使用，在 <code>nemu/include/macro.h</code> 中有：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span>
<span class="normal">4</span>
<span class="normal">5</span>
<span class="normal">6</span>
<span class="normal">7</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#define concat_temp(x, y) x##y</span>
<span class="cp">#define concat(x, y) concat_temp(x, y)</span>
<span class="cp">#define concat3(x, y, z) concat(concat(x, y), z)</span>
<span class="cp">#define concat4(x, y, z, w) concat3(concat(x, y), z, w)</span>
<span class="cp">#define concat5(x, y, z, v, w) concat4(concat(x, y), z, v, w)</span>
<span class="cp">#define concat6(x, y, z, v, w, u) concat5(concat(x, y), z, v, w, u)</span>
<span class="cp">#define concat7(x, y, z, v, w, u, h) concat6(concat(x, y), z, v, w, u, h)</span>
</code></pre></div></td></tr></table></div>
<p>由于宏操作的特性，它可以用来拼接函数名：</p>
<p>比如 <code>make_instr_func(mov_i2rm_v)</code>，可以写成</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="n">make_instr_func</span><span class="p">(</span><span class="n">concat7</span><span class="p">(</span><span class="n">mov</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="n">rm</span><span class="p">,</span><span class="w"> </span><span class="n">_</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">))</span>
</code></pre></div></td></tr></table></div>
<p>一个非常方便的使用例</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="cp">#define make_instr_impl_2op(inst_name, src_type, dest_type, suffix)    \</span>
<span class="cp">    make_instr_func(concat7(inst_name, _, src_type, 2, dest_type, _, suffix))</span>
</code></pre></div></td></tr></table></div>
<p>这种宏展开匹配函数名的方式可以极大的简化分支操作</p>
</div>
<ul>
<li>所有的指令的签名都是一样的（符合 <code>opcode_entry</code> 的要求），所以可以简化函数声明：</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// From nemu/include/cpu/instr_helper.h</span>
<span class="c1">// macro for making an instruction entry</span>
<span class="cp">#define make_instr_func(name) int name(uint32_t eip, uint8_t opcode)</span>
</code></pre></div></td></tr></table></div>
<p>此时 <code>int mov_i2rm_v(uint32_t eip, uint8_t opcode)</code> 可以重写为 <code>make_instr_func(mov_i2rm_v)</code> </p>
<ul>
<li>NEMU 不存在指令并发，所以可以将指令的操作数修改为全局变量，规范命名并且节省栈空间</li>
</ul>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// From nemu/src/cpu/decode/operand.c</span>
<span class="n">OPERAND</span><span class="w"> </span><span class="n">opr_src</span><span class="p">,</span><span class="w"> </span><span class="n">opr_dest</span><span class="p">;</span>
</code></pre></div></td></tr></table></div>
<ul>
<li>不难发现，对于很多两操作数指令，都满足下面的步骤：解码两个操作数 -&gt; 进行实际的指令操作（比如mov） -&gt; 返回指令长度</li>
</ul>
<p>这让我们尝试统一所有符合上述规则的函数：</p>
<p>··· 这些指令的名字都符合 <code>"inst_name"_"src_type"'2'"dest_type"_"suffix"</code> 的命名规范（比如 <code>mov_i2rm_v</code>），因此我可以构造一个 <code>make_instr_impl_2op(inst_name, src_type, dest_type, suffix)</code> 的大框架，通过输入各个参数的内容就可以映射到对应的两操作数指令（借助 <code>concat</code> 宏实现）</p>
<p>··· 接下来实现两个解码操作数的函数封装（分别是操作数长度与操作数寻址的函数）</p>
<p>··· 然后一个限定在单个文件内的 <code>static instr_execute_2op();</code> 函数，在每个文件内（代表一个类型的指令）分别指代同一种操作</p>
<p>··· 最后统一返回长度</p>
<p>在 <code>instr_helper.h</code> 中，我们有了对应的实现：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// 一个实现部分两操作数指令的模板</span>
<span class="c1">// decode_data_size 与 decode_operand 系列的指令也在 instr_helper.h 中实现，自行分析</span>

<span class="c1">// macro for generating the implementation of an instruction with two operands</span>
<span class="cp">#define make_instr_impl_2op(inst_name, src_type, dest_type, suffix)                                                                        \</span>
<span class="cp"> make_instr_func(concat7(inst_name, _, src_type, 2, dest_type, _, suffix))                                                              \</span>
<span class="cp"> {                                                                                                                                      \</span>
<span class="cp">     int len = 1;                                                                                                                       \</span>
<span class="cp">     concat(decode_data_size_, suffix)                                                                                                  \</span>
<span class="cp">     concat3(decode_operand, _, concat3(src_type, 2, dest_type))                                                                    \</span>
<span class="cp">     print_asm_2(#inst_name, opr_dest.data_size == 8 ? &quot;b&quot; : (opr_dest.data_size == 16 ? &quot;w&quot; : &quot;l&quot;), len, &amp;opr_src, &amp;opr_dest); \</span>
<span class="cp">     instr_execute_2op();                                                                                                               \</span>
<span class="cp">     return len;                                                                                                                        \</span>
<span class="cp"> }</span>
</code></pre></div></td></tr></table></div>
<p>对于 <code>mov</code> 系指令，我们最终有下面的写法：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 1</span>
<span class="normal"> 2</span>
<span class="normal"> 3</span>
<span class="normal"> 4</span>
<span class="normal"> 5</span>
<span class="normal"> 6</span>
<span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="c1">// 所有mov指令共享的执行方法</span>
<span class="c1">// static 使得 instr_execute_2op() 只会在 mov.c 中生效，实现隔离</span>
<span class="k">static</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="nf">instr_execute_2op</span><span class="p">()</span><span class="w"> </span><span class="p">{</span>
<span class="w">    </span><span class="n">operand_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opr_src</span><span class="p">);</span>
<span class="w">    </span><span class="n">opr_dest</span><span class="p">.</span><span class="n">val</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">opr_src</span><span class="p">.</span><span class="n">val</span><span class="p">;</span>
<span class="w">    </span><span class="n">operand_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">opr_dest</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 这里的每一行指令在宏展开后都是完整的实现</span>
<span class="n">make_instr_impl_2op</span><span class="p">(</span><span class="n">mov</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">rm</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="n">make_instr_impl_2op</span><span class="p">(</span><span class="n">mov</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">rm</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="n">make_instr_impl_2op</span><span class="p">(</span><span class="n">mov</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">rm</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="n">make_instr_impl_2op</span><span class="p">(</span><span class="n">mov</span><span class="p">,</span><span class="w"> </span><span class="n">rm</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">)</span>
<span class="p">...</span>
</code></pre></div></td></tr></table></div>
<p><code>mov</code> 函数的主要实现已经在 <code>mov.c</code> 中完成，作为举例</p>
<hr />
<p>在 <code>instr_helper.h</code> 中，我们实现了一操作数/两操作数指令的完整逻辑（满足<strong>取数 -&gt; 执行 -&gt; 返回长度</strong>的指令），同时对 <code>jcc</code> 系指令也有了相对应的 <code>cc</code> 版宏实现</p>
<blockquote>
<p>根据框架代码的构筑经验，适用和不适用宏的指令分别是：</p>
<ul>
<li>
<p>适用宏的指令：<code>adc</code>, <code>add</code>, <code>and</code>, <code>bt</code>, <code>cbw</code>, <code>cmov</code>, <code>cmp</code>, <code>dec</code>, <code>inc</code>, <code>jcc</code>, 大多数的<code>mov</code>, <code>not</code>, <code>or</code>, <code>pop</code>, <code>push</code>, <code>sar</code>, <code>sbb</code>, <code>setcc</code>, <code>shl</code>, <code>shr</code>, <code>sub</code>, <code>test</code>, <code>xor</code></p>
</li>
<li>
<p>不适用的指令：<code>call</code>, <code>cltd</code>, <code>cmps</code>, <code>div</code>, <code>idiv</code>, <code>mul</code>, <code>imul</code>, <code>cld</code>, <code>clc</code>, <code>sahf</code>, <code>hlt</code>, <code>int</code>, <code>jmp</code>, <code>lea</code>, <code>leave</code>, <code>rep</code>, <code>ret</code>, <code>stos</code>, <code>x87</code></p>
</li>
</ul>
</blockquote>
<h2 id="-">---分隔线---</h2>
<h2 id="tips-when-completing-pa">Tips when completing PA</h2>
<div class="admonition success">
<p class="admonition-title">为防止剧透，几乎所有的 Tips 都被折叠</p>
<p>（Tips 指的是本人在实际完成 PA 时认为有推动性帮助的点）</p>
</div>
<details class="tip" open="open">
<summary>老师给出的有关 pop / push 实现的建议</summary>
<blockquote>
<p><code>push</code> 和 <code>pop</code> 建议不管 <code>data_size</code>原来是多少，都扩展到 32 位再操作</p>
</blockquote>
</details>
<details class="tip">
<summary>关于填写 <code>opcode_entry</code> / 函数名如何命名 / 我需要实现哪些小函数的问题</summary>
<p>在 <code>opcode.c</code> 文件的同级目录下有一个 <code>opcode_ref.c</code> 文件，你会发现删除所有的 <code>__ref_</code> 后，其余的内容就是你需要在 <code>opcode.c</code> 中填写的内容</p>
<p>你只需要选择性的 Ctrl C+V，然后 Ctrl+F 删掉就能获得一个大致填写完成的 <code>opcode.c</code> 文件，同时还附赠了你需要具体实现的每一个子函数的名称</p>
<p><strong>注意你不应该一次复制整个 <code>opcode_ref.c</code>，你复制的函数都需要被实现才能通过编译</strong>，你应该只复制实现的部分</p>
<p>另外：对于 PA 2-1，你不需要实现所有的函数，所以部分函数使用 <code>__ref_</code> 版本不影响完成</p>
</details>
<details class="tip">
<summary>编译时出现了 <code>./include/cpu/instr_helper.h:14:31: error: expected '=', ',', ';', 'asm' or '__attribute__' before 'int'</code> 之类的报错？</summary>
<p><code>/nemu/src/cpu/instr</code> 里面的每一项头文件都检查一下 <code>make_instr_func();</code> 有没有漏加分号</p>
<p>由于宏展开的神秘特性，报错所在的文件位置不一定正确</p>
<p>个人经历：“<code>push.h</code> 没加分号怎么报错报在了 <code>div.h</code> 😨”（发送于凌晨三点）</p>
</details>
<details class="tip">
<summary>我在某一个 testcase 出现了 <strong>HIT <font color="#FF0000">BAD</font> TRAP</strong>，但是我并不知道自己的函数实现中有哪些错误，如何排查</summary>
<p>每一个函数都有一个 <code>__ref_</code> 版本的标准实现。如果你大概能确定可能是哪一条指令出了问题，就将它在 <code>opcode_entry[]</code> 中加上 <code>__ref_</code>，如果再次测试（记得先 <code>make</code>）发现 <strong>HIT <font color="#00FF00">GOOD</font> TRAP</strong>，说明你刚刚加上 <code>__ref_</code> 的指令的实现有问题；</p>
<p>如果你不清楚哪一条指令出了问题，那就将所有涉及到这个样例的指令全部加上 <code>__ref_</code>，一个个解除 <code>__ref_</code>，直到出现 <strong>HIT <font color="#FF0000">BAD</font> TRAP</strong>，说明最后一个解除 <code>__ref_</code> 的函数实现有问题</p>
</details>
<details class="tip">
<summary>我在某一个 testcase 出现了 <code>invalid opcode</code> 报错</summary>
<p>如果这个 opcode 是预期的，检查 <code>opcode_entry[]</code> 是否忘记添加函数</p>
<p>如果这个 opcode 不是预期的，那么大概率是其他指令的实现有问题（比如返回了错误的 <code>len</code>）。你可以用上面一条提到的 <code>__ref_</code> 方案尝试找到错误的函数，也可以采用 monitor 的单步执行操作，定位出现 <code>invalid opcode</code> 前最后执行的 opcode</p>
<p>（个人经历：我在实现 <code>and</code> 函数时没有注意符号扩展，导致 <code>quick-sort</code> 测试点出现数值溢出，地址在将近 1w 步执行后直接跳转到了 <code>0x0</code> 左右的位置，并最终 <code>invalid opcode</code> 。在这个不常见的经历中，<code>__ref_</code> 是最直接的排查方案）</p>
</details>
<details class="tip">
<summary>我将全部的指令都 <code>__ref_</code> 了，但是依旧 <strong>HIT <font color="#FF0000">BAD</font> TRAP</strong></summary>
<p>这不应该，根据测试，全部使用参考实现可以通过所有的 testcases（<code>test-float</code> 除外）</p>
<p><del>需要思考自己是不是动过不该动的东西了</del>，或者再次确认有没有忘记 <code>__ref_</code> 化的函数</p>
</details>
<details class="tip">
<summary>我在 <code>make</code> 时没有看到红色的编译报错信息，但是我在调用 nemu 进行 test 时发现 <code>command not found</code>，没有生成 nemu 可执行文件</summary>
<p>说明 <code>make</code> 确实没有编译问题，但是可能<strong>存在链接问题</strong>，此时不会有红色的报错，而是正常颜色，混在正常的编译信息中，比如：</p>
<div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">1</span>
<span class="normal">2</span>
<span class="normal">3</span></pre></div></td><td class="code"><div><pre><span></span><code>undefined reference to &#39;xxx&#39;
collect2: error: ld returned 1 exit status
make-[1]: *** [Makefile:13: nemu] Error 1
</code></pre></div></td></tr></table></div>
<p>上面的例子说明你声明了一个函数但是从来没有实现它，这是一个链接阶段的错误，而不是编译阶段的错误，所以没有彩色的报错提示</p>
</details>
<details class="tip">
<summary>为什么我没有使用 <code>__ref_</code> 完成指令，某个 testcase 依旧提醒 “<font color="#FF0000">You have used reference implementation, DO NOT submit this version.</font>”</summary>
<p>首先确认一下自己是不是真的在这个 testcase 所需要的指令中完全没有使用 <code>__ref_</code> </p>
<p>然后引用老师的解答：</p>
<blockquote>
<p>这一般是因为某整数运算相关的指令，当遇到两个操作数长度不一样的时候，没有在调用alu对应运算函数前先统一操作数长度导致的</p>
<p>统一的时候要用sign_ext函数做符号扩展</p>
</blockquote>
</details>
<details class="tip">
<summary>样例测试的时候出现了 <code>load_exec: Assertion 'fp != 0' failed</code></summary>
<p>意思是 nemu 没有找到样例文件</p>
<p>说明你把样例的名字输错了（应该没有后缀名）/ 你手搓了一个样例但是没有生成可执行文件</p>
</details>
<details class="tip">
<summary>不好奇一下 <code>__ref_</code> 是如何实现的吗</summary>
<p>在 <code>libs/nemu-ref/lib-nemu-ref.a</code> 中（<code>.a</code> 文件可以看作多个 <code>.o</code> 文件的打包文件）有每个 <code>__ref_</code> 函数的实现，你可以用逆向工具将其反汇编为汇编语言/反编译为 C 语言</p>
<p>可以反编译 <code>__ref_</code> 函数来了解某个函数的实现方式，虽然非常不直观</p>
<p><img src="https://img.cdn1.vip/i/68ef094475a2c_1760495940.webp" alt="image.png"></p>
</details>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../../..", "features": ["content.code.copy"], "search": "../../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../../assets/javascripts/bundle.f55a23d4.min.js"></script>
      
        <script src="../../../stylesheets/extra.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
      
        <script src="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>